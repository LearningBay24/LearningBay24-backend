// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// User is an object representing the database table.
type User struct {
	ID int `boil:"id" json:"id" toml:"id" yaml:"id"`
	// The title this user has.
	Title     null.String `boil:"title" json:"title,omitempty" toml:"title" yaml:"title,omitempty"`
	Firstname string      `boil:"firstname" json:"firstname" toml:"firstname" yaml:"firstname"`
	Surname   string      `boil:"surname" json:"surname" toml:"surname" yaml:"surname"`
	Email     string      `boil:"email" json:"email" toml:"email" yaml:"email"`
	// The password stored as a bcrypt hash.
	Password []byte `boil:"password" json:"password" toml:"password" yaml:"password"`
	// The role this user has.
	RoleID int `boil:"role_id" json:"role_id" toml:"role_id" yaml:"role_id"`
	// What prior graduation level the user has.
	GraduationLevel null.Int `boil:"graduation_level" json:"graduation_level,omitempty" toml:"graduation_level" yaml:"graduation_level,omitempty"`
	// The current semester of the user. This can be NULL as the user doesn't have to be a "student" (or similar).
	Semester null.Int `boil:"semester" json:"semester,omitempty" toml:"semester" yaml:"semester,omitempty"`
	// Phone numbers are only stored with numbers - the rest is done in the application.
	PhoneNumber null.String `boil:"phone_number" json:"phone_number,omitempty" toml:"phone_number" yaml:"phone_number,omitempty"`
	// General place of residency.
	Residence null.String `boil:"residence" json:"residence,omitempty" toml:"residence" yaml:"residence,omitempty"`
	// Profile picture this user has created.
	ProfilePicture null.Int `boil:"profile_picture" json:"profile_picture,omitempty" toml:"profile_picture" yaml:"profile_picture,omitempty"`
	// Something the user writes about themself.
	Biography null.String `boil:"biography" json:"biography,omitempty" toml:"biography" yaml:"biography,omitempty"`
	// Preferred language of the user.
	PreferredLanguageID int       `boil:"preferred_language_id" json:"preferred_language_id" toml:"preferred_language_id" yaml:"preferred_language_id"`
	CreatedAt           time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt           null.Time `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt           null.Time `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *userR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
	ID                  string
	Title               string
	Firstname           string
	Surname             string
	Email               string
	Password            string
	RoleID              string
	GraduationLevel     string
	Semester            string
	PhoneNumber         string
	Residence           string
	ProfilePicture      string
	Biography           string
	PreferredLanguageID string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
}{
	ID:                  "id",
	Title:               "title",
	Firstname:           "firstname",
	Surname:             "surname",
	Email:               "email",
	Password:            "password",
	RoleID:              "role_id",
	GraduationLevel:     "graduation_level",
	Semester:            "semester",
	PhoneNumber:         "phone_number",
	Residence:           "residence",
	ProfilePicture:      "profile_picture",
	Biography:           "biography",
	PreferredLanguageID: "preferred_language_id",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
	DeletedAt:           "deleted_at",
}

var UserTableColumns = struct {
	ID                  string
	Title               string
	Firstname           string
	Surname             string
	Email               string
	Password            string
	RoleID              string
	GraduationLevel     string
	Semester            string
	PhoneNumber         string
	Residence           string
	ProfilePicture      string
	Biography           string
	PreferredLanguageID string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
}{
	ID:                  "user.id",
	Title:               "user.title",
	Firstname:           "user.firstname",
	Surname:             "user.surname",
	Email:               "user.email",
	Password:            "user.password",
	RoleID:              "user.role_id",
	GraduationLevel:     "user.graduation_level",
	Semester:            "user.semester",
	PhoneNumber:         "user.phone_number",
	Residence:           "user.residence",
	ProfilePicture:      "user.profile_picture",
	Biography:           "user.biography",
	PreferredLanguageID: "user.preferred_language_id",
	CreatedAt:           "user.created_at",
	UpdatedAt:           "user.updated_at",
	DeletedAt:           "user.deleted_at",
}

// Generated where

type whereHelper__byte struct{ field string }

func (w whereHelper__byte) EQ(x []byte) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelper__byte) NEQ(x []byte) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelper__byte) LT(x []byte) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelper__byte) LTE(x []byte) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelper__byte) GT(x []byte) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelper__byte) GTE(x []byte) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var UserWhere = struct {
	ID                  whereHelperint
	Title               whereHelpernull_String
	Firstname           whereHelperstring
	Surname             whereHelperstring
	Email               whereHelperstring
	Password            whereHelper__byte
	RoleID              whereHelperint
	GraduationLevel     whereHelpernull_Int
	Semester            whereHelpernull_Int
	PhoneNumber         whereHelpernull_String
	Residence           whereHelpernull_String
	ProfilePicture      whereHelpernull_Int
	Biography           whereHelpernull_String
	PreferredLanguageID whereHelperint
	CreatedAt           whereHelpertime_Time
	UpdatedAt           whereHelpernull_Time
	DeletedAt           whereHelpernull_Time
}{
	ID:                  whereHelperint{field: "`user`.`id`"},
	Title:               whereHelpernull_String{field: "`user`.`title`"},
	Firstname:           whereHelperstring{field: "`user`.`firstname`"},
	Surname:             whereHelperstring{field: "`user`.`surname`"},
	Email:               whereHelperstring{field: "`user`.`email`"},
	Password:            whereHelper__byte{field: "`user`.`password`"},
	RoleID:              whereHelperint{field: "`user`.`role_id`"},
	GraduationLevel:     whereHelpernull_Int{field: "`user`.`graduation_level`"},
	Semester:            whereHelpernull_Int{field: "`user`.`semester`"},
	PhoneNumber:         whereHelpernull_String{field: "`user`.`phone_number`"},
	Residence:           whereHelpernull_String{field: "`user`.`residence`"},
	ProfilePicture:      whereHelpernull_Int{field: "`user`.`profile_picture`"},
	Biography:           whereHelpernull_String{field: "`user`.`biography`"},
	PreferredLanguageID: whereHelperint{field: "`user`.`preferred_language_id`"},
	CreatedAt:           whereHelpertime_Time{field: "`user`.`created_at`"},
	UpdatedAt:           whereHelpernull_Time{field: "`user`.`updated_at`"},
	DeletedAt:           whereHelpernull_Time{field: "`user`.`deleted_at`"},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
	ProfilePictureFile       string
	UserGraduationLevel      string
	PreferredLanguage        string
	Role                     string
	Certificates             string
	CreatorExams             string
	UploaderFiles            string
	AuthorForumEntries       string
	UserToNotifications      string
	UserHasCourses           string
	UserHasExams             string
	FieldOfStudies           string
	SubmitterUserSubmissions string
}{
	ProfilePictureFile:       "ProfilePictureFile",
	UserGraduationLevel:      "UserGraduationLevel",
	PreferredLanguage:        "PreferredLanguage",
	Role:                     "Role",
	Certificates:             "Certificates",
	CreatorExams:             "CreatorExams",
	UploaderFiles:            "UploaderFiles",
	AuthorForumEntries:       "AuthorForumEntries",
	UserToNotifications:      "UserToNotifications",
	UserHasCourses:           "UserHasCourses",
	UserHasExams:             "UserHasExams",
	FieldOfStudies:           "FieldOfStudies",
	SubmitterUserSubmissions: "SubmitterUserSubmissions",
}

// userR is where relationships are stored.
type userR struct {
	ProfilePictureFile       *File               `boil:"ProfilePictureFile" json:"ProfilePictureFile" toml:"ProfilePictureFile" yaml:"ProfilePictureFile"`
	UserGraduationLevel      *GraduationLevel    `boil:"UserGraduationLevel" json:"UserGraduationLevel" toml:"UserGraduationLevel" yaml:"UserGraduationLevel"`
	PreferredLanguage        *Language           `boil:"PreferredLanguage" json:"PreferredLanguage" toml:"PreferredLanguage" yaml:"PreferredLanguage"`
	Role                     *Role               `boil:"Role" json:"Role" toml:"Role" yaml:"Role"`
	Certificates             CertificateSlice    `boil:"Certificates" json:"Certificates" toml:"Certificates" yaml:"Certificates"`
	CreatorExams             ExamSlice           `boil:"CreatorExams" json:"CreatorExams" toml:"CreatorExams" yaml:"CreatorExams"`
	UploaderFiles            FileSlice           `boil:"UploaderFiles" json:"UploaderFiles" toml:"UploaderFiles" yaml:"UploaderFiles"`
	AuthorForumEntries       ForumEntrySlice     `boil:"AuthorForumEntries" json:"AuthorForumEntries" toml:"AuthorForumEntries" yaml:"AuthorForumEntries"`
	UserToNotifications      NotificationSlice   `boil:"UserToNotifications" json:"UserToNotifications" toml:"UserToNotifications" yaml:"UserToNotifications"`
	UserHasCourses           UserHasCourseSlice  `boil:"UserHasCourses" json:"UserHasCourses" toml:"UserHasCourses" yaml:"UserHasCourses"`
	UserHasExams             UserHasExamSlice    `boil:"UserHasExams" json:"UserHasExams" toml:"UserHasExams" yaml:"UserHasExams"`
	FieldOfStudies           FieldOfStudySlice   `boil:"FieldOfStudies" json:"FieldOfStudies" toml:"FieldOfStudies" yaml:"FieldOfStudies"`
	SubmitterUserSubmissions UserSubmissionSlice `boil:"SubmitterUserSubmissions" json:"SubmitterUserSubmissions" toml:"SubmitterUserSubmissions" yaml:"SubmitterUserSubmissions"`
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR {
	return &userR{}
}

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
	userAllColumns            = []string{"id", "title", "firstname", "surname", "email", "password", "role_id", "graduation_level", "semester", "phone_number", "residence", "profile_picture", "biography", "preferred_language_id", "created_at", "updated_at", "deleted_at"}
	userColumnsWithoutDefault = []string{"title", "firstname", "surname", "email", "password", "role_id", "graduation_level", "semester", "phone_number", "residence", "profile_picture", "biography", "preferred_language_id", "updated_at", "deleted_at"}
	userColumnsWithDefault    = []string{"id", "created_at"}
	userPrimaryKeyColumns     = []string{"id"}
	userGeneratedColumns      = []string{}
)

type (
	// UserSlice is an alias for a slice of pointers to User.
	// This should almost always be used instead of []User.
	UserSlice []*User
	// UserHook is the signature for custom User hook methods
	UserHook func(context.Context, boil.ContextExecutor, *User) error

	userQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userType                 = reflect.TypeOf(&User{})
	userMapping              = queries.MakeStructMapping(userType)
	userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
	userInsertCacheMut       sync.RWMutex
	userInsertCache          = make(map[string]insertCache)
	userUpdateCacheMut       sync.RWMutex
	userUpdateCache          = make(map[string]updateCache)
	userUpsertCacheMut       sync.RWMutex
	userUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var userAfterSelectHooks []UserHook

var userBeforeInsertHooks []UserHook
var userAfterInsertHooks []UserHook

var userBeforeUpdateHooks []UserHook
var userAfterUpdateHooks []UserHook

var userBeforeDeleteHooks []UserHook
var userAfterDeleteHooks []UserHook

var userBeforeUpsertHooks []UserHook
var userAfterUpsertHooks []UserHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *User) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *User) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *User) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *User) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *User) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *User) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *User) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *User) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *User) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUserHook registers your hook function for all future operations.
func AddUserHook(hookPoint boil.HookPoint, userHook UserHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		userAfterSelectHooks = append(userAfterSelectHooks, userHook)
	case boil.BeforeInsertHook:
		userBeforeInsertHooks = append(userBeforeInsertHooks, userHook)
	case boil.AfterInsertHook:
		userAfterInsertHooks = append(userAfterInsertHooks, userHook)
	case boil.BeforeUpdateHook:
		userBeforeUpdateHooks = append(userBeforeUpdateHooks, userHook)
	case boil.AfterUpdateHook:
		userAfterUpdateHooks = append(userAfterUpdateHooks, userHook)
	case boil.BeforeDeleteHook:
		userBeforeDeleteHooks = append(userBeforeDeleteHooks, userHook)
	case boil.AfterDeleteHook:
		userAfterDeleteHooks = append(userAfterDeleteHooks, userHook)
	case boil.BeforeUpsertHook:
		userBeforeUpsertHooks = append(userBeforeUpsertHooks, userHook)
	case boil.AfterUpsertHook:
		userAfterUpsertHooks = append(userAfterUpsertHooks, userHook)
	}
}

// One returns a single user record from the query.
func (q userQuery) One(ctx context.Context, exec boil.ContextExecutor) (*User, error) {
	o := &User{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for user")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all User records from the query.
func (q userQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserSlice, error) {
	var o []*User

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to User slice")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count user rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if user exists")
	}

	return count > 0, nil
}

// ProfilePictureFile pointed to by the foreign key.
func (o *User) ProfilePictureFile(mods ...qm.QueryMod) fileQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.ProfilePicture),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Files(queryMods...)
	queries.SetFrom(query.Query, "`file`")

	return query
}

// UserGraduationLevel pointed to by the foreign key.
func (o *User) UserGraduationLevel(mods ...qm.QueryMod) graduationLevelQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.GraduationLevel),
	}

	queryMods = append(queryMods, mods...)

	query := GraduationLevels(queryMods...)
	queries.SetFrom(query.Query, "`graduation_level`")

	return query
}

// PreferredLanguage pointed to by the foreign key.
func (o *User) PreferredLanguage(mods ...qm.QueryMod) languageQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.PreferredLanguageID),
	}

	queryMods = append(queryMods, mods...)

	query := Languages(queryMods...)
	queries.SetFrom(query.Query, "`language`")

	return query
}

// Role pointed to by the foreign key.
func (o *User) Role(mods ...qm.QueryMod) roleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.RoleID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Roles(queryMods...)
	queries.SetFrom(query.Query, "`role`")

	return query
}

// Certificates retrieves all the certificate's Certificates with an executor.
func (o *User) Certificates(mods ...qm.QueryMod) certificateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`certificate`.`user_id`=?", o.ID),
		qmhelper.WhereIsNull("`certificate`.`deleted_at`"),
	)

	query := Certificates(queryMods...)
	queries.SetFrom(query.Query, "`certificate`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`certificate`.*"})
	}

	return query
}

// CreatorExams retrieves all the exam's Exams with an executor via creator_id column.
func (o *User) CreatorExams(mods ...qm.QueryMod) examQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`exam`.`creator_id`=?", o.ID),
		qmhelper.WhereIsNull("`exam`.`deleted_at`"),
	)

	query := Exams(queryMods...)
	queries.SetFrom(query.Query, "`exam`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`exam`.*"})
	}

	return query
}

// UploaderFiles retrieves all the file's Files with an executor via uploader_id column.
func (o *User) UploaderFiles(mods ...qm.QueryMod) fileQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`file`.`uploader_id`=?", o.ID),
		qmhelper.WhereIsNull("`file`.`deleted_at`"),
	)

	query := Files(queryMods...)
	queries.SetFrom(query.Query, "`file`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`file`.*"})
	}

	return query
}

// AuthorForumEntries retrieves all the forum_entry's ForumEntries with an executor via author_id column.
func (o *User) AuthorForumEntries(mods ...qm.QueryMod) forumEntryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`forum_entry`.`author_id`=?", o.ID),
		qmhelper.WhereIsNull("`forum_entry`.`deleted_at`"),
	)

	query := ForumEntries(queryMods...)
	queries.SetFrom(query.Query, "`forum_entry`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`forum_entry`.*"})
	}

	return query
}

// UserToNotifications retrieves all the notification's Notifications with an executor via user_to_id column.
func (o *User) UserToNotifications(mods ...qm.QueryMod) notificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`notification`.`user_to_id`=?", o.ID),
		qmhelper.WhereIsNull("`notification`.`deleted_at`"),
	)

	query := Notifications(queryMods...)
	queries.SetFrom(query.Query, "`notification`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`notification`.*"})
	}

	return query
}

// UserHasCourses retrieves all the user_has_course's UserHasCourses with an executor.
func (o *User) UserHasCourses(mods ...qm.QueryMod) userHasCourseQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`user_has_course`.`user_id`=?", o.ID),
		qmhelper.WhereIsNull("`user_has_course`.`deleted_at`"),
	)

	query := UserHasCourses(queryMods...)
	queries.SetFrom(query.Query, "`user_has_course`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`user_has_course`.*"})
	}

	return query
}

// UserHasExams retrieves all the user_has_exam's UserHasExams with an executor.
func (o *User) UserHasExams(mods ...qm.QueryMod) userHasExamQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`user_has_exam`.`user_id`=?", o.ID),
		qmhelper.WhereIsNull("`user_has_exam`.`deleted_at`"),
	)

	query := UserHasExams(queryMods...)
	queries.SetFrom(query.Query, "`user_has_exam`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`user_has_exam`.*"})
	}

	return query
}

// FieldOfStudies retrieves all the field_of_study's FieldOfStudies with an executor.
func (o *User) FieldOfStudies(mods ...qm.QueryMod) fieldOfStudyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("`user_has_field_of_study` on `field_of_study`.`id` = `user_has_field_of_study`.`field_of_study_id`"),
		qm.Where("`user_has_field_of_study`.`user_id`=?", o.ID),
	)

	query := FieldOfStudies(queryMods...)
	queries.SetFrom(query.Query, "`field_of_study`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`field_of_study`.*"})
	}

	return query
}

// SubmitterUserSubmissions retrieves all the user_submission's UserSubmissions with an executor via submitter_id column.
func (o *User) SubmitterUserSubmissions(mods ...qm.QueryMod) userSubmissionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`user_submission`.`submitter_id`=?", o.ID),
		qmhelper.WhereIsNull("`user_submission`.`deleted_at`"),
	)

	query := UserSubmissions(queryMods...)
	queries.SetFrom(query.Query, "`user_submission`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`user_submission`.*"})
	}

	return query
}

// LoadProfilePictureFile allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadProfilePictureFile(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.ProfilePicture) {
			args = append(args, object.ProfilePicture)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProfilePicture) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProfilePicture) {
				args = append(args, obj.ProfilePicture)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`file`),
		qm.WhereIn(`file.id in ?`, args...),
		qmhelper.WhereIsNull(`file.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load File")
	}

	var resultSlice []*File
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice File")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for file")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for file")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProfilePictureFile = foreign
		if foreign.R == nil {
			foreign.R = &fileR{}
		}
		foreign.R.ProfilePictureUsers = append(foreign.R.ProfilePictureUsers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProfilePicture, foreign.ID) {
				local.R.ProfilePictureFile = foreign
				if foreign.R == nil {
					foreign.R = &fileR{}
				}
				foreign.R.ProfilePictureUsers = append(foreign.R.ProfilePictureUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadUserGraduationLevel allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadUserGraduationLevel(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.GraduationLevel) {
			args = append(args, object.GraduationLevel)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GraduationLevel) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.GraduationLevel) {
				args = append(args, obj.GraduationLevel)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`graduation_level`),
		qm.WhereIn(`graduation_level.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load GraduationLevel")
	}

	var resultSlice []*GraduationLevel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice GraduationLevel")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for graduation_level")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for graduation_level")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UserGraduationLevel = foreign
		if foreign.R == nil {
			foreign.R = &graduationLevelR{}
		}
		foreign.R.Users = append(foreign.R.Users, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.GraduationLevel, foreign.ID) {
				local.R.UserGraduationLevel = foreign
				if foreign.R == nil {
					foreign.R = &graduationLevelR{}
				}
				foreign.R.Users = append(foreign.R.Users, local)
				break
			}
		}
	}

	return nil
}

// LoadPreferredLanguage allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadPreferredLanguage(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.PreferredLanguageID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.PreferredLanguageID {
					continue Outer
				}
			}

			args = append(args, obj.PreferredLanguageID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`language`),
		qm.WhereIn(`language.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Language")
	}

	var resultSlice []*Language
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Language")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for language")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for language")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PreferredLanguage = foreign
		if foreign.R == nil {
			foreign.R = &languageR{}
		}
		foreign.R.PreferredLanguageUsers = append(foreign.R.PreferredLanguageUsers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PreferredLanguageID == foreign.ID {
				local.R.PreferredLanguage = foreign
				if foreign.R == nil {
					foreign.R = &languageR{}
				}
				foreign.R.PreferredLanguageUsers = append(foreign.R.PreferredLanguageUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadRole allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadRole(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.RoleID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.RoleID {
					continue Outer
				}
			}

			args = append(args, obj.RoleID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`role`),
		qm.WhereIn(`role.id in ?`, args...),
		qmhelper.WhereIsNull(`role.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Role")
	}

	var resultSlice []*Role
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Role")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for role")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for role")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Role = foreign
		if foreign.R == nil {
			foreign.R = &roleR{}
		}
		foreign.R.Users = append(foreign.R.Users, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.RoleID == foreign.ID {
				local.R.Role = foreign
				if foreign.R == nil {
					foreign.R = &roleR{}
				}
				foreign.R.Users = append(foreign.R.Users, local)
				break
			}
		}
	}

	return nil
}

// LoadCertificates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCertificates(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`certificate`),
		qm.WhereIn(`certificate.user_id in ?`, args...),
		qmhelper.WhereIsNull(`certificate.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load certificate")
	}

	var resultSlice []*Certificate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice certificate")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on certificate")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for certificate")
	}

	if len(certificateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Certificates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &certificateR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.Certificates = append(local.R.Certificates, foreign)
				if foreign.R == nil {
					foreign.R = &certificateR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorExams allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatorExams(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`exam`),
		qm.WhereIn(`exam.creator_id in ?`, args...),
		qmhelper.WhereIsNull(`exam.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load exam")
	}

	var resultSlice []*Exam
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice exam")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on exam")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for exam")
	}

	if len(examAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorExams = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &examR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatorID {
				local.R.CreatorExams = append(local.R.CreatorExams, foreign)
				if foreign.R == nil {
					foreign.R = &examR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadUploaderFiles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUploaderFiles(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`file`),
		qm.WhereIn(`file.uploader_id in ?`, args...),
		qmhelper.WhereIsNull(`file.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load file")
	}

	var resultSlice []*File
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice file")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on file")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for file")
	}

	if len(fileAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UploaderFiles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &fileR{}
			}
			foreign.R.Uploader = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UploaderID {
				local.R.UploaderFiles = append(local.R.UploaderFiles, foreign)
				if foreign.R == nil {
					foreign.R = &fileR{}
				}
				foreign.R.Uploader = local
				break
			}
		}
	}

	return nil
}

// LoadAuthorForumEntries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadAuthorForumEntries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`forum_entry`),
		qm.WhereIn(`forum_entry.author_id in ?`, args...),
		qmhelper.WhereIsNull(`forum_entry.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load forum_entry")
	}

	var resultSlice []*ForumEntry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice forum_entry")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on forum_entry")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for forum_entry")
	}

	if len(forumEntryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AuthorForumEntries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &forumEntryR{}
			}
			foreign.R.Author = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AuthorID {
				local.R.AuthorForumEntries = append(local.R.AuthorForumEntries, foreign)
				if foreign.R == nil {
					foreign.R = &forumEntryR{}
				}
				foreign.R.Author = local
				break
			}
		}
	}

	return nil
}

// LoadUserToNotifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserToNotifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`notification`),
		qm.WhereIn(`notification.user_to_id in ?`, args...),
		qmhelper.WhereIsNull(`notification.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load notification")
	}

	var resultSlice []*Notification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice notification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on notification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for notification")
	}

	if len(notificationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserToNotifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &notificationR{}
			}
			foreign.R.UserTo = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserToID {
				local.R.UserToNotifications = append(local.R.UserToNotifications, foreign)
				if foreign.R == nil {
					foreign.R = &notificationR{}
				}
				foreign.R.UserTo = local
				break
			}
		}
	}

	return nil
}

// LoadUserHasCourses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserHasCourses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_has_course`),
		qm.WhereIn(`user_has_course.user_id in ?`, args...),
		qmhelper.WhereIsNull(`user_has_course.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_has_course")
	}

	var resultSlice []*UserHasCourse
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_has_course")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_has_course")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_has_course")
	}

	if len(userHasCourseAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserHasCourses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userHasCourseR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserHasCourses = append(local.R.UserHasCourses, foreign)
				if foreign.R == nil {
					foreign.R = &userHasCourseR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserHasExams allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserHasExams(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_has_exam`),
		qm.WhereIn(`user_has_exam.user_id in ?`, args...),
		qmhelper.WhereIsNull(`user_has_exam.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_has_exam")
	}

	var resultSlice []*UserHasExam
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_has_exam")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_has_exam")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_has_exam")
	}

	if len(userHasExamAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserHasExams = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userHasExamR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserHasExams = append(local.R.UserHasExams, foreign)
				if foreign.R == nil {
					foreign.R = &userHasExamR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadFieldOfStudies allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadFieldOfStudies(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("`field_of_study`.id, `field_of_study`.name, `field_of_study`.semesters, `field_of_study`.created_at, `field_of_study`.updated_at, `field_of_study`.deleted_at, `a`.`user_id`"),
		qm.From("`field_of_study`"),
		qm.InnerJoin("`user_has_field_of_study` as `a` on `field_of_study`.`id` = `a`.`field_of_study_id`"),
		qm.WhereIn("`a`.`user_id` in ?", args...),
		qmhelper.WhereIsNull("`field_of_study`.`deleted_at`"),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load field_of_study")
	}

	var resultSlice []*FieldOfStudy

	var localJoinCols []int
	for results.Next() {
		one := new(FieldOfStudy)
		var localJoinCol int

		err = results.Scan(&one.ID, &one.Name, &one.Semesters, &one.CreatedAt, &one.UpdatedAt, &one.DeletedAt, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for field_of_study")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice field_of_study")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on field_of_study")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for field_of_study")
	}

	if len(fieldOfStudyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FieldOfStudies = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &fieldOfStudyR{}
			}
			foreign.R.Users = append(foreign.R.Users, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ID == localJoinCol {
				local.R.FieldOfStudies = append(local.R.FieldOfStudies, foreign)
				if foreign.R == nil {
					foreign.R = &fieldOfStudyR{}
				}
				foreign.R.Users = append(foreign.R.Users, local)
				break
			}
		}
	}

	return nil
}

// LoadSubmitterUserSubmissions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadSubmitterUserSubmissions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_submission`),
		qm.WhereIn(`user_submission.submitter_id in ?`, args...),
		qmhelper.WhereIsNull(`user_submission.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_submission")
	}

	var resultSlice []*UserSubmission
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_submission")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_submission")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_submission")
	}

	if len(userSubmissionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SubmitterUserSubmissions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userSubmissionR{}
			}
			foreign.R.Submitter = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.SubmitterID {
				local.R.SubmitterUserSubmissions = append(local.R.SubmitterUserSubmissions, foreign)
				if foreign.R == nil {
					foreign.R = &userSubmissionR{}
				}
				foreign.R.Submitter = local
				break
			}
		}
	}

	return nil
}

// SetProfilePictureFile of the user to the related item.
// Sets o.R.ProfilePictureFile to related.
// Adds o to related.R.ProfilePictureUsers.
func (o *User) SetProfilePictureFile(ctx context.Context, exec boil.ContextExecutor, insert bool, related *File) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `user` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"profile_picture"}),
		strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProfilePicture, related.ID)
	if o.R == nil {
		o.R = &userR{
			ProfilePictureFile: related,
		}
	} else {
		o.R.ProfilePictureFile = related
	}

	if related.R == nil {
		related.R = &fileR{
			ProfilePictureUsers: UserSlice{o},
		}
	} else {
		related.R.ProfilePictureUsers = append(related.R.ProfilePictureUsers, o)
	}

	return nil
}

// RemoveProfilePictureFile relationship.
// Sets o.R.ProfilePictureFile to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *User) RemoveProfilePictureFile(ctx context.Context, exec boil.ContextExecutor, related *File) error {
	var err error

	queries.SetScanner(&o.ProfilePicture, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("profile_picture")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProfilePictureFile = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ProfilePictureUsers {
		if queries.Equal(o.ProfilePicture, ri.ProfilePicture) {
			continue
		}

		ln := len(related.R.ProfilePictureUsers)
		if ln > 1 && i < ln-1 {
			related.R.ProfilePictureUsers[i] = related.R.ProfilePictureUsers[ln-1]
		}
		related.R.ProfilePictureUsers = related.R.ProfilePictureUsers[:ln-1]
		break
	}
	return nil
}

// SetUserGraduationLevel of the user to the related item.
// Sets o.R.UserGraduationLevel to related.
// Adds o to related.R.Users.
func (o *User) SetUserGraduationLevel(ctx context.Context, exec boil.ContextExecutor, insert bool, related *GraduationLevel) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `user` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"graduation_level"}),
		strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.GraduationLevel, related.ID)
	if o.R == nil {
		o.R = &userR{
			UserGraduationLevel: related,
		}
	} else {
		o.R.UserGraduationLevel = related
	}

	if related.R == nil {
		related.R = &graduationLevelR{
			Users: UserSlice{o},
		}
	} else {
		related.R.Users = append(related.R.Users, o)
	}

	return nil
}

// RemoveUserGraduationLevel relationship.
// Sets o.R.UserGraduationLevel to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *User) RemoveUserGraduationLevel(ctx context.Context, exec boil.ContextExecutor, related *GraduationLevel) error {
	var err error

	queries.SetScanner(&o.GraduationLevel, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("graduation_level")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.UserGraduationLevel = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Users {
		if queries.Equal(o.GraduationLevel, ri.GraduationLevel) {
			continue
		}

		ln := len(related.R.Users)
		if ln > 1 && i < ln-1 {
			related.R.Users[i] = related.R.Users[ln-1]
		}
		related.R.Users = related.R.Users[:ln-1]
		break
	}
	return nil
}

// SetPreferredLanguage of the user to the related item.
// Sets o.R.PreferredLanguage to related.
// Adds o to related.R.PreferredLanguageUsers.
func (o *User) SetPreferredLanguage(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Language) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `user` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"preferred_language_id"}),
		strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PreferredLanguageID = related.ID
	if o.R == nil {
		o.R = &userR{
			PreferredLanguage: related,
		}
	} else {
		o.R.PreferredLanguage = related
	}

	if related.R == nil {
		related.R = &languageR{
			PreferredLanguageUsers: UserSlice{o},
		}
	} else {
		related.R.PreferredLanguageUsers = append(related.R.PreferredLanguageUsers, o)
	}

	return nil
}

// SetRole of the user to the related item.
// Sets o.R.Role to related.
// Adds o to related.R.Users.
func (o *User) SetRole(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Role) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `user` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"role_id"}),
		strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.RoleID = related.ID
	if o.R == nil {
		o.R = &userR{
			Role: related,
		}
	} else {
		o.R.Role = related
	}

	if related.R == nil {
		related.R = &roleR{
			Users: UserSlice{o},
		}
	} else {
		related.R.Users = append(related.R.Users, o)
	}

	return nil
}

// AddCertificates adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Certificates.
// Sets related.R.User appropriately.
func (o *User) AddCertificates(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Certificate) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `certificate` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, certificatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			Certificates: related,
		}
	} else {
		o.R.Certificates = append(o.R.Certificates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &certificateR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddCreatorExams adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatorExams.
// Sets related.R.Creator appropriately.
func (o *User) AddCreatorExams(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Exam) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatorID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `exam` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, examPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatorID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatorExams: related,
		}
	} else {
		o.R.CreatorExams = append(o.R.CreatorExams, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &examR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// AddUploaderFiles adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UploaderFiles.
// Sets related.R.Uploader appropriately.
func (o *User) AddUploaderFiles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*File) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UploaderID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `file` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"uploader_id"}),
				strmangle.WhereClause("`", "`", 0, filePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UploaderID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UploaderFiles: related,
		}
	} else {
		o.R.UploaderFiles = append(o.R.UploaderFiles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &fileR{
				Uploader: o,
			}
		} else {
			rel.R.Uploader = o
		}
	}
	return nil
}

// AddAuthorForumEntries adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.AuthorForumEntries.
// Sets related.R.Author appropriately.
func (o *User) AddAuthorForumEntries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ForumEntry) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AuthorID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `forum_entry` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"author_id"}),
				strmangle.WhereClause("`", "`", 0, forumEntryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AuthorID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			AuthorForumEntries: related,
		}
	} else {
		o.R.AuthorForumEntries = append(o.R.AuthorForumEntries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &forumEntryR{
				Author: o,
			}
		} else {
			rel.R.Author = o
		}
	}
	return nil
}

// AddUserToNotifications adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserToNotifications.
// Sets related.R.UserTo appropriately.
func (o *User) AddUserToNotifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Notification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserToID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `notification` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_to_id"}),
				strmangle.WhereClause("`", "`", 0, notificationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserToID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserToNotifications: related,
		}
	} else {
		o.R.UserToNotifications = append(o.R.UserToNotifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &notificationR{
				UserTo: o,
			}
		} else {
			rel.R.UserTo = o
		}
	}
	return nil
}

// AddUserHasCourses adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserHasCourses.
// Sets related.R.User appropriately.
func (o *User) AddUserHasCourses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserHasCourse) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `user_has_course` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, userHasCoursePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.UserID, rel.CourseID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserHasCourses: related,
		}
	} else {
		o.R.UserHasCourses = append(o.R.UserHasCourses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userHasCourseR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserHasExams adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserHasExams.
// Sets related.R.User appropriately.
func (o *User) AddUserHasExams(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserHasExam) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `user_has_exam` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, userHasExamPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.UserID, rel.ExamID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserHasExams: related,
		}
	} else {
		o.R.UserHasExams = append(o.R.UserHasExams, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userHasExamR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddFieldOfStudies adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.FieldOfStudies.
// Sets related.R.Users appropriately.
func (o *User) AddFieldOfStudies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FieldOfStudy) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into `user_has_field_of_study` (`user_id`, `field_of_study_id`) values (?, ?)"
		values := []interface{}{o.ID, rel.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, query)
			fmt.Fprintln(writer, values)
		}
		_, err = exec.ExecContext(ctx, query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &userR{
			FieldOfStudies: related,
		}
	} else {
		o.R.FieldOfStudies = append(o.R.FieldOfStudies, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &fieldOfStudyR{
				Users: UserSlice{o},
			}
		} else {
			rel.R.Users = append(rel.R.Users, o)
		}
	}
	return nil
}

// SetFieldOfStudies removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Users's FieldOfStudies accordingly.
// Replaces o.R.FieldOfStudies with related.
// Sets related.R.Users's FieldOfStudies accordingly.
func (o *User) SetFieldOfStudies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FieldOfStudy) error {
	query := "delete from `user_has_field_of_study` where `user_id` = ?"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeFieldOfStudiesFromUsersSlice(o, related)
	if o.R != nil {
		o.R.FieldOfStudies = nil
	}
	return o.AddFieldOfStudies(ctx, exec, insert, related...)
}

// RemoveFieldOfStudies relationships from objects passed in.
// Removes related items from R.FieldOfStudies (uses pointer comparison, removal does not keep order)
// Sets related.R.Users.
func (o *User) RemoveFieldOfStudies(ctx context.Context, exec boil.ContextExecutor, related ...*FieldOfStudy) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from `user_has_field_of_study` where `user_id` = ? and `field_of_study_id` in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ID}
	for _, rel := range related {
		values = append(values, rel.ID)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeFieldOfStudiesFromUsersSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FieldOfStudies {
			if rel != ri {
				continue
			}

			ln := len(o.R.FieldOfStudies)
			if ln > 1 && i < ln-1 {
				o.R.FieldOfStudies[i] = o.R.FieldOfStudies[ln-1]
			}
			o.R.FieldOfStudies = o.R.FieldOfStudies[:ln-1]
			break
		}
	}

	return nil
}

func removeFieldOfStudiesFromUsersSlice(o *User, related []*FieldOfStudy) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.Users {
			if o.ID != ri.ID {
				continue
			}

			ln := len(rel.R.Users)
			if ln > 1 && i < ln-1 {
				rel.R.Users[i] = rel.R.Users[ln-1]
			}
			rel.R.Users = rel.R.Users[:ln-1]
			break
		}
	}
}

// AddSubmitterUserSubmissions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.SubmitterUserSubmissions.
// Sets related.R.Submitter appropriately.
func (o *User) AddSubmitterUserSubmissions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserSubmission) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SubmitterID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `user_submission` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"submitter_id"}),
				strmangle.WhereClause("`", "`", 0, userSubmissionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SubmitterID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			SubmitterUserSubmissions: related,
		}
	} else {
		o.R.SubmitterUserSubmissions = append(o.R.SubmitterUserSubmissions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userSubmissionR{
				Submitter: o,
			}
		} else {
			rel.R.Submitter = o
		}
	}
	return nil
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery {
	mods = append(mods, qm.From("`user`"), qmhelper.WhereIsNull("`user`.`deleted_at`"))
	return userQuery{NewQuery(mods...)}
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*User, error) {
	userObj := &User{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `user` where `id`=? and `deleted_at` is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, userObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from user")
	}

	if err = userObj.doAfterSelectHooks(ctx, exec); err != nil {
		return userObj, err
	}

	return userObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no user provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userInsertCacheMut.RLock()
	cache, cached := userInsertCache[key]
	userInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `user` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `user` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `user` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into user")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == userMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for user")
	}

CacheNoHooks:
	if !cached {
		userInsertCacheMut.Lock()
		userInsertCache[key] = cache
		userInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	userUpdateCacheMut.RLock()
	cache, cached := userUpdateCache[key]
	userUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update user, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `user` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update user row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for user")
	}

	if !cached {
		userUpdateCacheMut.Lock()
		userUpdateCache[key] = cache
		userUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for user")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `user` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all user")
	}
	return rowsAff, nil
}

var mySQLUserUniqueColumns = []string{
	"id",
	"email",
	"phone_number",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no user provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLUserUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userUpsertCacheMut.RLock()
	cache, cached := userUpsertCache[key]
	userUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert user, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`user`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `user` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for user")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == userMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(userType, userMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for user")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for user")
	}

CacheNoHooks:
	if !cached {
		userUpsertCacheMut.Lock()
		userUpsertCache[key] = cache
		userUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no User provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
		sql = "DELETE FROM `user` WHERE `id`=?"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE `user` SET %s WHERE `id`=?",
			strmangle.SetParamNames("`", "`", 0, wl),
		)
		valueMapping, err := queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for user")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no userQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for user")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(userBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM `user` WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE `user` SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("`", "`", 0, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for user")
	}

	if len(userAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUser(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `user`.* FROM `user` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(*o)) +
		"and `deleted_at` is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in UserSlice")
	}

	*o = slice

	return nil
}

// UserExists checks if the User row exists.
func UserExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `user` where `id`=? and `deleted_at` is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if user exists")
	}

	return exists, nil
}
